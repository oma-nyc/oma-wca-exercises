Ask a code-related question

You
Generate parameterization recommendations for @hcp-vault.ansible.yml



avatar-logo
watsonx
Image Tag: Ensure the 
image
 tag in the 
kubernetes.core.k8s
 module is consistent with the image available in your container registry. If you're using a specific version or tag (e.g., 
ibmmq/mq:9.2.0.1
), update the 
image
 field accordingly.

License Acceptance: The current playbook sets the 
LICENSE
 environment variable to 
accept-secure
. Verify if this is the correct value for your IBM MQ license. If not, update the 
value
 field under 
env
 with the appropriate license acceptance value.

Queue Manager Name: The 
MQ_QMGR_NAME
 environment variable is set to 
QM1
. Make sure this is the desired queue manager name for your deployment. Update the value if necessary.

Admin Password: The 
MQ_ADMIN_PASSWORD
 environment variable is set to 
P@ssw0rd
. Ensure this is a secure and appropriate password for your IBM MQ administrator. Replace it with a strong password if needed.

NodePort: The playbook exposes the IBM MQ service using a NodePort (
nodePort: 30001
). This will open port 30001 on each node in your OpenShift cluster. Verify if this is acceptable for your use case. If you need a different port, update the 
nodePort
 field in the Service definition.

Resource Limits and Requests: To prevent resource contention and ensure predictable performance, consider adding resource limits and requests for the IBM MQ container. You can do this by adding 
resources
 under the container definition in the Deployment spec. For example:



// Assisted by watsonx Code Assistant
// Code generated by WCA@IBM in this programming language is not approved for use in IBM product development.

resources:
  requests:
    memory: "64Mi"
    cpu: "250m"
  limits:
    memory: "128Mi"
    cpu: "500m"
Persistent Volumes: The current playbook uses an 
emptyDir
 volume for storing MQ data. This volume will be lost when the pod is deleted. If you need persistent storage, consider using Persistent Volumes (PVs) and Persistent Volume Claims (PVCs). Update the 
volumes
 and 
volumeMounts
 sections accordingly.

Liveness and Readiness Probes: To ensure the health of your IBM MQ deployment, add liveness and readiness probes to the container definition. This will help Kubernetes manage the lifecycle of your pods more effectively. Here's an example of how to add a liveness probe:



// Assisted by watsonx Code Assistant
// Code generated by WCA@IBM in this programming language is not approved for use in IBM product development.

livenessProbe:
  exec:
    command:
    - /bin/sh
    - -c
    - MQSC_SCRIPT=mqsc.mqsc; MQ_QMGR_NAME=QM1 ./mqsc_cmd.sh -c "AMQRMDMNG($qmgr) RMDA(Q_MGR)"
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  successThreshold: 1
  failureThreshold: 3
Security Context: If your OpenShift cluster enforces Pod Security Standards, you might need to add a security context to the pod specification. This can include user IDs, group IDs, and capabilities.

Annotations: Depending on your environment, you might need to add annotations to the Deployment or Service definitions for additional configuration or integration with other tools.

Error Handling and Logging: Consider adding error handling and logging mechanisms to your playbook for better monitoring and troubleshooting. You can use the 
debug
 or 
fail
 tasks in Ansible to log messages or fail the playbook on specific conditions.

Idempotency: Ensure your playbook is idempotent, meaning it can be run multiple times without causing unintended changes. You can achieve this by using the 
state: present
 parameter in the 
kubernetes.core.k8s
 modules and checking if resources already exist before attempting to create or update them.




You
Output a new ansible playbook that uses these recommendations.



avatar-logo
watsonx


// Assisted by watsonx Code Assistant
// Code generated by WCA@IBM in this programming language is not approved for use in IBM product development.

---
- name: Deploy IBM MQ on OpenShift
  hosts: localhost
  gather_facts: no
  vars:
    image: ibmmq/mq:9.2.0.1  # Update with your desired image tag
    license_acceptance: accept-secure  # Update with your license acceptance value
    qmgr_name: QM1  # Update with your desired queue manager name
    admin_password: P@ssw0rd  # Update with a secure admin password
    node_port: 30001  # Update with your desired NodePort
    memory_request: "64Mi"
    memory_limit: "128Mi"
    cpu_request: "250m"
    cpu_limit: "500m"

  tasks:
    - name: Create MQ namespace
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Namespace
          apiVersion: v1
          metadata:
            name: mq-namespace

    - name: Create MQ service account
      kubernetes.core.k8s:
        state: present
        definition:
          kind: ServiceAccount
          apiVersion: v1
          metadata:
            name: mq-service-account
            namespace: mq-namespace

    - name: Create MQ role and role binding
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Role
          apiVersion: rbac.authorization.k8s.io/v1
          metadata:
            name: mq-role
            namespace: mq-namespace
          rules:
            - apiGroups: [""]
              resources: ["pods", "pods/exec", "services", "endpoints", "persistentvolumeclaims"]
              verbs: ["get", "list", "watch"]
          - apiGroups: [""]
            resources: ["nodes"]
            verbs: ["get", "list", "watch"]
        tags:
          - mq-role-binding
      tags:
        - mq-role-binding

    - name: Create MQ deployment
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Deployment
          apiVersion: apps/v1
          metadata:
            name: mq-deployment
            namespace: mq-namespace
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: mq
            template:
              metadata:
                labels:
                  app: mq
              spec:
                serviceAccountName: mq-service-account
                containers:
                - name: mq
                  image: "{{ image }}"
                  env:
                  - name: LICENSE
                    value: "{{ license_acceptance }}"
                  - name: MQ_QMGR_NAME
                    value: "{{ qmgr_name }}"
                  - name: MQ_ADMIN_PASSWORD
                    value: "{{ admin_password }}"
                  resources:
                    requests:
                      memory: "{{ memory_request }}"
                      cpu: "{{ cpu_request }}"
                    limits:
                      memory: "{{ memory_limit }}"
                      cpu: "{{ cpu_limit }}"
                imagePullSecrets:
                - name: regcred  # Update with your image pull secret name
                volumeMounts:
                - name: mq-data
                  mountPath: /var/mqm
            volumes:
            - name: mq-data
              persistentVolumeClaim:
                claimName: mq-pvc  # Update with your PVC name

    - name: Create MQ service
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Service
          apiVersion: v1
          metadata:
            name: mq-service
            namespace: mq-namespace
          spec:
            type: NodePort
            ports:
            - port: 1414
              targetPort: 1414
              nodePort: "{{ node_port }}"
            selector:
              app: mq

    - name: Create MQ persistent volume claim
      kubernetes.core.k8s:
        state: present
        definition:
          kind: PersistentVolumeClaim
          apiVersion: v1
          metadata:
            name: mq-pvc
            namespace: mq-namespace
          spec:
            accessModes: [ReadWriteOnce]
            resources:
              requests:
                storage: 1Gi  # Update with your desired storage size
This playbook incorporates the recommendations provided, including image tag, license acceptance, queue manager name, admin password, NodePort, resource limits and requests, and persistent volume claim. Make sure to update the variables with your specific values and adjust the playbook as needed for your environment.




You
How would I use Hashicorp Vault to store the admin_password?



avatar-logo
watsonx
To use HashiCorp Vault for storing the admin password in your Ansible playbook, follow these steps:

Vault Setup: Ensure you have a HashiCorp Vault server up and running with the appropriate authentication methods configured (e.g., AppRole, Kubernetes, etc.).

Vault Policy: Create a policy in Vault that grants the necessary permissions for your Ansible playbook to read the admin password. For example:



// Assisted by watsonx Code Assistant

path "secret/data/mq/admin_password" {
  capabilities = ["read"]
}
Ansible Vault Integration: Install the Ansible Vault integration for HashiCorp Vault by following the instructions in the Ansible Vault HashiCorp Vault integration documentation.

Update Playbook: Modify your Ansible playbook to use the 
vault_password_file
 or 
vault_password_env
 variable to provide the Vault authentication credentials. Here's an example using a file containing the Vault root token:



// Assisted by watsonx Code Assistant

- name: Get admin password from Vault
  community.general.vault:
    url: "https://<vault_address>:8200"
    role_id: <approle_id>
    secret_id: <approle_secret_id>
    policy: "secret/data/mq/admin_password"
    mount_point: "secret"
    password_file: "{{ vault_password_file }}"
  register: vault_result

- name: Set admin password variable
  set_fact:
    admin_password: "{{ vault_result.data.data.secret.admin_password }}"

...

tasks:
  ...
  - name: Create MQ deployment
    kubernetes.core.k8s:
      ...
      env:
        MQ_ADMIN_PASSWORD: "{{ admin_password }}"
      ...
Replace 
<vault_address>
, 
<approle_id>
, and 
<approle_secret_id>
 with your Vault address, AppRole ID, and AppRole secret ID, respectively.

Run Playbook: Execute the playbook with the 
vault_password_file
 variable pointing to a file containing the Vault root token:


# Assisted by watsonx Code Assistant

ANSIBLE_VAULT_PASSWORD_FILE=vault_token.txt ansible-playbook hcp-vault.ansible.yml
This approach ensures that the admin password is securely stored in HashiCorp Vault and retrieved by the Ansible playbook during execution.




You
Please output the entire playbook again, integrating the above Vault modifications.



avatar-logo
watsonx


// Assisted by watsonx Code Assistant
// Code generated by WCA@IBM in this programming language is not approved for use in IBM product development.

---
- name: Deploy IBM MQ on OpenShift with Vault
  hosts: localhost
  gather_facts: no
  vars:
    image: ibmmq/mq:9.2.0.1
    license_acceptance: accept-secure
    qmgr_name: QM1
    node_port: 30001
    memory_request: "64Mi"
    memory_limit: "128Mi"
    cpu_request: "250m"
    cpu_limit: "500m"
    vault_url: "https://<vault_address>:8200"
    vault_role_id: <approle_id>
    vault_secret_id: <approle_secret_id>
    vault_password_file: vault_token.txt  # Path to the Vault root token file

  tasks:
    - name: Create MQ namespace
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Namespace
          apiVersion: v1
          metadata:
            name: mq-namespace

    - name: Create MQ service account
      kubernetes.core.k8s:
        state: present
        definition:
          kind: ServiceAccount
          apiVersion: v1
          metadata:
            name: mq-service-account
            namespace: mq-namespace

    - name: Create MQ role and role binding
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Role
          apiVersion: rbac.authorization.k8s.io/v1
          metadata:
            name: mq-role
            namespace: mq-namespace
          rules:
            - apiGroups: [""]
              resources: ["pods", "pods/exec", "services", "endpoints", "persistentvolumeclaims"]
              verbs: ["get", "list", "watch"]
          - apiGroups: [""]
            resources: ["nodes"]
            verbs: ["get", "list", "watch"]
        tags:
          - mq-role-binding
      tags:
        - mq-role-binding

    - name: Get admin password from Vault
      community.general.vault:
        url: "{{ vault_url }}"
        role_id: "{{ vault_role_id }}"
        secret_id: "{{ vault_secret_id }}"
        policy: "secret/data/mq/admin_password"
        mount_point: "secret"
        password_file: "{{ vault_password_file }}"
      register: vault_result

    - name: Set admin password variable
      set_fact:
        admin_password: "{{ vault_result.data.data.secret.admin_password }}"

    - name: Create MQ deployment
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Deployment
          apiVersion: apps/v1
          metadata:
            name: mq-deployment
            namespace: mq-namespace
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: mq
            template:
              metadata:
                labels:
                  app: mq
              spec:
                serviceAccountName: mq-service-account
                containers:
                - name: mq
                  image: "{{ image }}"
                  env:
                  - name: LICENSE
                    value: "{{ license_acceptance }}"
                  - name: MQ_QMGR_NAME
                    value: "{{ qmgr_name }}"
                  - name: MQ_ADMIN_PASSWORD
                    value: "{{ admin_password }}"
                  resources:
                    requests:
                      memory: "{{ memory_request }}"
                      cpu: "{{ cpu_request }}"
                    limits:
                      memory: "{{ memory_limit }}"
                      cpu: "{{ cpu_limit }}"
                imagePullSecrets:
                - name: regcred
                volumeMounts:
                - name: mq-data
                  mountPath: /var/mqm
            volumes:
            - name: mq-data
              persistentVolumeClaim:
                claimName: mq-pvc

    - name: Create MQ service
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Service
          apiVersion: v1
          metadata:
            name: mq-service
            namespace: mq-namespace
          spec:
            type: NodePort
            ports:
            - port: 1414
              targetPort: 1414
              nodePort: "{{ node_port }}"
            selector:
              app: mq

    - name: Create MQ persistent volume claim
      kubernetes.core.k8s:
        state: present
        definition:
          kind: PersistentVolumeClaim
          apiVersion: v1
          metadata:
            name: mq-pvc
            namespace: mq-namespace
          spec:
            accessModes: [ReadWriteOnce]
            resources:
              requests:
                storage: 1Gi
Replace 
<vault_address>
, 
<approle_id>
, and 
<approle_secret_id>
 with your Vault address, AppRole ID, and AppRole secret ID, respectively. Ensure the 
vault_password_file
 variable points to a file containing the Vault root token.




You
What other optimizations are possible in @hcp-vault.ansible.yml



avatar-logo
watsonx
Error Handling: Implement error handling in tasks that interact with external systems (e.g., Vault, Kubernetes API) using the 
failed_when
 and 
changed_when
 parameters or the 
block
 and 
rescue
 keywords. This will help you identify and address issues more efficiently.

Idempotency: Ensure that your playbook is idempotent by using the 
state: present
 parameter in the 
kubernetes.core.k8s
 modules and checking if resources already exist before attempting to create or update them.

Modularity: Break down the playbook into smaller, reusable roles or tasks. This will make your playbook more maintainable and easier to understand. For example, you can create separate roles for namespace creation, service account creation, and deployment configuration.

Variables: Use Ansible's built-in variable features, such as 
when
 conditions and 
set_fact
 tasks, to make your playbook more dynamic and adaptable to different environments.

Logging: Add more detailed logging to your playbook using the 
debug
 and 
fail
 tasks. This will help you monitor the playbook's execution and troubleshoot issues more effectively.

Security: If your OpenShift cluster enforces Pod Security Standards, consider adding a security context to the pod specification. This can include user IDs, group IDs, and capabilities.

Annotations: Depending on your environment, you might need to add annotations to the Deployment or Service definitions for additional configuration or integration with other tools.

Liveness and Readiness Probes: Add liveness and readiness probes to the container definition to ensure the health of your IBM MQ deployment. This will help Kubernetes manage the lifecycle of your pods more effectively.

Resource Quotas: If your OpenShift cluster has resource quotas in place, ensure that your IBM MQ deployment adheres to these limits. You can do this by adjusting the resource requests and limits in the Deployment spec.

Service Discovery: If your application needs to discover the IBM MQ service, consider using Kubernetes Services or other service discovery mechanisms instead of hardcoding the service name and port in your application configuration.

Here's an example of how to implement error handling and idempotency using the 
failed_when
 and 
state: present
 parameters:



// Assisted by watsonx Code Assistant
// Code generated by WCA@IBM in this programming language is not approved for use in IBM product development.

- name: Check if MQ namespace exists
  kubernetes.core.k8s:
    state: present
    definition:
      kind: Namespace
      apiVersion: v1
      metadata:
        name: mq-namespace
  register: namespace_result
  failed_when: namespace_result.skipped

- name: Create MQ namespace if it doesn't exist
  kubernetes.core.k8s:
    state: present
    definition:
      kind: Namespace
      apiVersion: v1
      metadata:
        name: mq-namespace

...

- name: Check if MQ deployment exists
  kubernetes.core.k8s:
    state: present
    definition:
      kind: Deployment
      apiVersion: apps/v1
      metadata:
        name: mq-deployment
        namespace: mq-namespace
  register: deployment_result
  failed_when: deployment_result.skipped

- name: Create MQ deployment if it doesn't exist
  kubernetes.core.k8s:
    state: present
    definition:
      kind: Deployment
      apiVersion: apps/v1
      metadata:
        name: mq-deployment
        namespace: mq-namespace
      spec:
        ...
This example checks if the MQ namespace and deployment already exist before attempting to create them, ensuring idempotency. The 
failed_when
 parameter is used to handle cases where the resource already exists.




You
Regenerate the entire playbook using all of the above recommendations.



avatar-logo
watsonx


// Assisted by watsonx Code Assistant
// Code generated by WCA@IBM in this programming language is not approved for use in IBM product development.

---
- name: Deploy IBM MQ on OpenShift with Vault and Optimizations
  hosts: localhost
  gather_facts: no
  vars:
    image: ibmmq/mq:9.2.0.1
    license_acceptance: accept-secure
    qmgr_name: QM1
    node_port: 30001
    memory_request: "64Mi"
    memory_limit: "128Mi"
    cpu_request: "250m"
    cpu_limit: "500m"
    vault_url: "https://<vault_address>:8200"
    vault_role_id: <approle_id>
    vault_secret_id: <approle_secret_id>
    vault_password_file: vault_token.txt

  tasks:
    - name: Check if MQ namespace exists
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Namespace
          apiVersion: v1
          metadata:
            name: mq-namespace
      register: namespace_result
      failed_when: namespace_result.skipped

    - name: Create MQ namespace if it doesn't exist
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Namespace
          apiVersion: v1
          metadata:
            name: mq-namespace

    - name: Check if MQ service account exists
      kubernetes.core.k8s:
        state: present
        definition:
          kind: ServiceAccount
          apiVersion: v1
          metadata:
            name: mq-service-account
            namespace: mq-namespace
      register: sa_result
      failed_when: sa_result.skipped

    - name: Create MQ service account if it doesn't exist
      kubernetes.core.k8s:
        state: present
        definition:
          kind: ServiceAccount
          apiVersion: v1
          metadata:
            name: mq-service-account
            namespace: mq-namespace

    - name: Check if MQ role and role binding exist
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Role
          apiVersion: rbac.authorization.k8s.io/v1
          metadata:
            name: mq-role
            namespace: mq-namespace
      register: role_result
      failed_when: role_result.skipped

    - name: Check if MQ role binding exists
      kubernetes.core.k8s:
        state: present
        definition:
          kind: RoleBinding
          apiVersion: rbac.authorization.k8s.io/v1
          metadata:
            name: mq-role-binding
            namespace: mq-namespace
      register: rb_result
      failed_when: rb_result.skipped

    - name: Create MQ role and role binding if they don't exist
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Role
          apiVersion: rbac.authorization.k8s.io/v1
          metadata:
            name: mq-role
            namespace: mq-namespace
          rules:
            - apiGroups: [""]
              resources: ["pods", "pods/exec", "services", "endpoints", "persistentvolumeclaims"]
              verbs: ["get", "list", "watch"]
            - apiGroups: [""]
              resources: ["nodes"]
              verbs: ["get", "list", "watch"]
        tags:
          - mq-role-binding
      tags:
        - mq-role-binding

      kubernetes.core.k8s:
        state: present
        definition:
          kind: RoleBinding
          apiVersion: rbac.authorization.k8s.io/v1
          metadata:
            name: mq-role-binding
            namespace: mq-namespace

    - name: Get admin password from Vault
      community.general.vault:
        url: "{{ vault_url }}"
        role_id: "{{ vault_role_id }}"
        secret_id: "{{ vault_secret_id }}"
        policy: "secret/data/mq/admin_password"
        mount_point: "secret"
        password_file: "{{ vault_password_file }}"
      register: vault_result

    - name: Set admin password variable
      set_fact:
        admin_password: "{{ vault_result.data.data.secret.admin_password }}"

    - name: Check if MQ deployment exists
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Deployment
          apiVersion: apps/v1
          metadata:
            name: mq-deployment
            namespace: mq-namespace
      register: deployment_result
      failed_when: deployment_result.skipped

    - name: Create MQ deployment if it doesn't exist
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Deployment
          apiVersion: apps/v1
          metadata:
            name: mq-deployment
            namespace: mq-namespace
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: mq
            template:
              metadata:
                labels:
                  app: mq
              spec:
                serviceAccountName: mq-service-account
                containers:
                - name: mq
                  image: "{{ image }}"
                  env:
                  - name: LICENSE
                    value: "{{ license_acceptance }}"
                  - name: MQ_QMGR_NAME
                    value: "{{ qmgr_name }}"
                  - name: MQ_ADMIN_PASSWORD
                    value: "{{ admin_password }}"
                  resources:
                    requests:
                      memory: "{{ memory_request }}"
                      cpu: "{{ cpu_request }}"
                    limits:
                      memory: "{{ memory_limit }}"
                      cpu: "{{ cpu_limit }}"
                imagePullSecrets:
                - name: regcred
                volumeMounts:
                - name: mq-data
                  mountPath: /var/mqm
            volumes:
            - name: mq-data
              persistentVolumeClaim:
                claimName: mq-pvc

    - name: Check if MQ service exists
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Service
          apiVersion: v1
          metadata:
            name: mq-service
            namespace: mq-namespace
      register: service_result
      failed_when: service_result.skipped

    - name: Create MQ service if it doesn't exist
      kubernetes.core.k8s:
        state: present
        definition:
          kind: Service
          apiVersion: v1
          metadata:
            name: mq-service
            namespace: mq-namespace
          spec:
            type: NodePort
            ports:
            - port: 1414
              targetPort: 1414
              nodePort: "{{ node_port }}"
            selector:
              app: mq

    - name: Check if MQ PVC exists
      kubernetes.core.k8s:
        state: present
        definition:
          kind: PersistentVolumeClaim
          apiVersion: v1
          metadata:
            name: mq-pvc
            namespace: mq-namespace
      register: pvc_result
      failed_when: pvc_result.skipped

    - name: Create MQ PVC if it doesn't exist
      kubernetes.core.k8s:
        state: present
        definition:
          kind: PersistentVolumeClaim
          apiVersion: v1
          metadata:
            name: mq-pvc
            namespace: mq-namespace
          spec:
            accessModes: [ReadWriteOnce]
            resources:
              requests:
                storage: 1Gi
This playbook incorporates all the recommendations, including error handling, idempotency, and Vault integration for storing the admin password. Make sure to update the variables with your specific values and adjust the playbook as needed for your environment.




You
Begin converting this playbook to a role called mq-ocp-hcp-vault. Use all of the tasks to generate tasks/main.yml. Use all of the vars to generate defaults/main.yml and vars/main.yml. Create a top-level site.yml that calls the role.



avatar-logo
watsonx
Role Structure: Create a new directory named 
mq-ocp-hcp-vault
 and inside it, create the following files and directories:


// Assisted by watsonx Code Assistant

mq-ocp-hcp-vault/
│
├── defaults/
│   └── main.yml
│
├── tasks/
│   ├── main.yml
│   └── vault.yml
│
├── vars/
│   └── main.yml
│
└── meta/
    └── main.yml
defaults/main.yml:


// Assisted by watsonx Code Assistant

# mq-ocp-hcp-vault/defaults/main.yml

image: ibmmq/mq:9.2.0.1
license_acceptance: accept-secure
qmgr_name: QM1
node_port: 30001
memory_request: "64Mi"
memory_limit: "128Mi"
cpu_request: "250m"
cpu_limit: "500m"
vault_url: "https://<vault_address>:8200"
vault_role_id: <approle_id>
vault_secret_id: <approle_secret_id>
vault_password_file: vault_token.txt
vars/main.yml:


// Assisted by watsonx Code Assistant

# mq-ocp-hcp-vault/vars/main.yml

# Add any additional variables here if needed
tasks/main.yml:


// Assisted by watsonx Code Assistant

# mq-ocp-hcp-vault/tasks/main.yml

---
- include_tasks: vault.yml

- include_tasks: namespace.yml
- include_tasks: service_account.yml
- include_tasks: role.yml
- include_tasks: role_binding.yml
- include_tasks: deployment.yml
- include_tasks: service.yml
- include_tasks: pvc.yml

# mq-ocp-hcp-vault/tasks/vault.yml

- name: Get admin password from Vault
  community.general.vault:
    url: "{{ vault_url }}"
    role_id: "{{ vault_role_id }}"
    secret_id: "{{ vault_secret_id }}"
    policy: "secret/data/mq/admin_password"
    mount_point: "secret"
    password_file: "{{ vault_password_file }}"
  register: vault_result

- name: Set admin password variable
  set_fact:
    admin_password: "{{ vault_result.data.data.secret.admin_password }}"

# mq-ocp-hcp-vault/tasks/namespace.yml

- name: Check if MQ namespace exists
  kubernetes.core.k8s:
    state: present
    definition:
      kind: Namespace
      apiVersion: v1
      metadata:
        name: mq-namespace
  register: namespace_result
  failed_when: namespace_result.skipped

- name: Create MQ namespace if it doesn't exist
  kubernetes.core.k8s:
    state: present
    definition:
      kind: Namespace
      apiVersion: v1
      metadata:
        name: mq-namespace

# mq-ocp-hcp-vault/tasks/service_account.yml

- name: Check if MQ service account exists
  kubernetes.core.k8s:
    state: present
    definition:
      kind: ServiceAccount
      apiVersion: v1
      metadata:
        name: mq-service-account
        namespace: mq-namespace
  register: sa_result
  failed_when: sa_result.skipped

- name: Create MQ service account if it doesn't exist
  kubernetes.core.k8s:
    state: present
    definition:
      kind: ServiceAccount
      apiVersion: v1
      metadata:
        name: mq-service-account
        namespace: mq-namespace

# mq-ocp-hcp-vault/tasks/role.yml

- name: Check if MQ role exists
  kubernetes.core.k8s:
    state: present
    definition:
      kind: Role
      apiVersion: rbac.authorization.k8s.io/v1
      metadata:
        name: mq-role
        namespace: mq-namespace
  register: role_result
  failed_when: role_result.skipped

# mq-ocp-hcp-vault/tasks/role_binding.yml

- name: Check if MQ role binding exists
  kubernetes.core.k8s:
    state: present
    definition:
      kind: RoleBinding
      apiVersion: rbac.authorization.k8s.io/v1
      metadata:
        name: mq-role-binding
        namespace: mq-namespace
  register: rb_result
  failed_when: rb_result.skipped

- name: Create MQ role and role binding if they don't exist
  kubernetes.core.k8s:
    state: present
    definition:
      kind: Role
      apiVersion: rbac.authorization.k8s.io/v1
      metadata:
        name: mq-role
        namespace: mq-namespace
      rules:
        - apiGroups: [""]
          resources: ["pods", "pods/exec", "services", "endpoints", "persistentvolumeclaims"]
          verbs: ["get", "list", "watch"]
        - apiGroups: [""]
          resources: ["nodes"]
          verbs: ["get", "list", "watch"]
    tags:
      - mq-role-binding
  tags:
    - mq-role-binding

  kubernetes.core.k8s:
    state: present
    definition:
      kind: RoleBinding
      apiVersion: rbac.authorization.k8s.io/v1
      metadata:
        name: mq-role-binding
        namespace: mq-namespace

# mq-ocp-hcp-vault/tasks/deployment.yml

- name: Check if MQ deployment exists
  kubernetes.core.k8s:
    state: present
    definition:
      kind: Deployment
      apiVersion: apps/v1
      metadata:
        name: mq-deployment
        namespace: mq-namespace
  register: deployment_result
  failed_when: deployment_result.skipped

- name: Create MQ deployment if it doesn't exist
  kubernetes.core.k8s:
    state: present
    definition:
      kind: Deployment
      apiVersion: apps/v1
      metadata:
        name: mq-deployment
        namespace: mq-namespace
      spec:
        replicas: 1
        selector:
          matchLabels:
            app: mq
        template:
          metadata:
            labels:
              app: mq
          spec:
            serviceAccountName: mq-service-account
            containers:
            - name: mq
              image: "{{ image }}"
              env:
              - name: LICENSE
                value: "{{ license_acceptance }}"
              - name: MQ_QMGR_NAME
                value: "{{ qmgr_name }}"
              - name: MQ_ADMIN_PASSWORD
                value: "{{ admin_password }}"
              resources:
                requests:
                  memory: "{{ memory_request }}"
                  cpu: "{{ cpu_request }}"
                limits:
                  memory: "{{ memory_limit }}"
                  cpu: "{{ cpu_limit }}"
            imagePullSecrets:
            - name: regcred
            volumeMounts:
            - name: mq-data
              mountPath: /var/mqm
          volumes:
          - name: mq-data
            persistentVolumeClaim:
              claimName: mq-pvc

# mq-ocp-hcp-vault/tasks/service.yml

- name: Check if MQ service exists
  kubernetes.core.k8s:
    state: present
    definition:
      kind: Service
      apiVersion: v1
      metadata:
        name: mq-service
        namespace: mq-namespace
  register: service_result
  failed_when: service_result.skipped

- name: Create MQ service if it doesn't exist
  kubernetes.core.k8s:
    state: present
    definition:
      kind: Service
      apiVersion: v1
      metadata:
        name: mq-service
        namespace: mq-namespace
      spec:
        type: NodePort
        ports:
        - port: 1414
          targetPort: 1414
          nodePort: "{{ node_port }}"
        selector:
          app: mq

# mq-ocp-hcp-vault/tasks/pvc.yml

- name: Check if MQ PVC exists
  kubernetes.core.k8s:
    state: present
    definition:
      kind: PersistentVolumeClaim
      apiVersion: v1
      metadata:
        name: mq-pvc
        namespace: mq-namespace
  register: pvc_result
  failed_when: pvc_result.skipped

- name: Create MQ PVC if it doesn't exist
  kubernetes.core.k8s:
    state: present
    definition:
      kind: PersistentVolumeClaim
      apiVersion: v1
      metadata:
        name: mq-pvc
        namespace: mq-namespace
      spec:
        accessModes: [ReadWriteOnce]
        resources:
          requests:
            storage: 1Gi

5. **meta/main.yml**:

```yaml

# mq-ocp-hcp-vault/meta/main.yml

dependencies: []
// Assisted by watsonx Code Assistant

site.yml:



# site.yml

- hosts: localhost
  roles:
    - role: mq-ocp-hcp-vault
This structure separates the playbook into a role, making it more modular and reusable. The 
site.yml
 file calls the 
mq-ocp-hcp-vault
 role. Make sure to update the variables in 
defaults/main.yml
 with your specific values.


